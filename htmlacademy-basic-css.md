<div align="center"><h1>Конспект: <a href="https://htmlacademy.ru/courses/basic-css">Основы CSS</a></h1></div>

## Оглавление.

- [**Глава 1: Знакомство с CSS**](#глава-1-знакомство-с-css)
  - [CSS-правило](#css-правило)
  - [Селекторы](#селекторы)
    - [1. По именам тегов.](#1-по-именам-тегов)
    - [2. По классам.](#2-по-классам)
  - [Оформление текста](#оформление-текста)
  - [Размеры и отступы](#размеры-и-отступы)
  - [Позиционирование.](#позиционирование)
  - [Сетки.](#сетки)
  - [Декоративные свойства.](#декоративные-свойства)
  - [Каскадность и приоритеты.](#каскадность-и-приоритеты)
  - [Наследование.](#наследование)
  
- [**Глава 2: Селекторы, часть 1**](#глава-2-селекторы-часть-1)
  - [1. По тегам](#1-по-тегам)
  - [2. По классам](#2-по-классам-1)
  - [3. Контекстные](#3-контекстные)
  - [4. Соседние селекторы](#4-соседние-селекторы)
  - [4b. Контекстные и соседние селекторы](#4b-контекстные-и-соседние-селекторы)
  - [5. Дочерние селекторы](#5-дочерние-селекторы)
  - [6. Селекторы атрибутов](#6-селекторы-атрибутов)
  - [7. Селекторы по id](#7-селекторы-по-id)
  - [Элементы: первый и последний](#элементы-первый-и-последний)
  - [Элементы: по порядковому номеру](#элементы-по-порядковому-номеру)
  - [Элементы: интерактивные](#элементы-интерактивные)
    - [A. Когда наведен курсор мыши](#a-когда-наведен-курсор-мыши)
    - [B. Псевдоклассы для ссылок](#b-псевдоклассы-для-ссылок)
    - [C. Элемент в фокусе (выделен)](#c-элемент-в-фокусе-выделен)
    
- [**Глава 3: Разметка текста**](#глава-3-разметка-текста)
  - [Иерархическое дерево](#иерархическое-дерево)
  - [Наследуемые свойства](#наследуемые-свойства)
  - [Ненаследуемые свойства](#ненаследуемые-свойства)
  - [Принудительное наследование](#принудительное-наследование)
  - [Каскадирование](#каскадирование)
  - [Специфичность селектора](#специфичность-селектора)
  - [Перекрестное наследование](#перекрестное-наследование)
  
- [**Глава 4: Селекторы, часть 2**](#глава-4-селекторы-часть-2)
  - [Элементы: содержащие сразу несколько селекторов](#элементы-содержащие-сразу-несколько-селекторов)
  - [Элементы: НЕ содержащие указанный селектор](#элементы-не-содержащие-указанный-селектор)
  - [Элементы: по порядковому номеру — с конца](8#элементы-по-порядковому-номеру--с-конца)
  - [Элементы: первый и последний — c учетом типа элемента](#элементы-первый-и-последний--c--учетом-типа-элемента)
    - [A. Первый элемент родителя с учетом типа элемента](#a-первый-элемент-родителя-с-учетом-типа-элемента)
    - [B. Последний элемент родителя с учетом типа элемента](#b-последний-элемент-родителя-с-учетом-типа-элемента)
  - [Элементы: по порядковому номеру — с учетом типа элемента](#элементы-по-порядковому-номеру--с-учетом-типа-элемента)
  - [Элементы: по порядковому номеру — с учетом типа элемента, с конца](#элементы-по-порядковому-номеру--с-учетом-типа-элемента-с-конца)
  - [Теги без дочерних элементов (и текстовых узлов)](#теги-без-дочерних-элементов-и-текстовых-узлов)
  - [Единственный дочерний элемент внутри родителя](#единственный-дочерний-элемент-внутри-родителя)
  - [Единственный дочерний элемент внутри родителя — c учетом типа элемента](#единственный-дочерний-элемент-внутри-родителя--c-учетом-типа-элемента)
  - [8. Селектор: последующие элементов](#8-селектор-последующие-элементов)
  - [Псевдотег: до элемента](#псевдотег-до-элемента)
  - [Псевдотег: после элемента](#псевдотег-после-элемента)
  - [Стиль: первой строки](#стиль-первой-строки)
  - [Стиль: первого символа](#стиль-первого-символа)
  
- [**Глава 5: Селекторы, часть 3**](#глава-5-селекторы-часть-3)
  - [Атрибуты: начинающиеся с определенных символов](#атрибуты-начинающиеся-с-определенных-символов)
  - [Атрибуты: заканчивающиеся определенными символами](#атрибуты-заканчивающиеся-определенными-символами)
  - [Атрибуты: имеющие в названии определенные символы](#атрибуты-имеющие-в-названии-определенные-символы)
  - [Атрибуты: имеющие в названии определенное слово](#атрибуты-имеющие-в-названии-определенное-слово)
  - [Атрибуты: имеющие в начале или содержащее определенные символы](#атрибуты-имеющие-в-начале-или-содержащее-определенные-символы)
  - [Элементы: не заблокированные и заблокированные](#элементы-не-заблокированные-и-заблокированные)
  - [Поля: доступные и недоступные для редактирования](#поля-доступные-и-недоступные-для-редактирования)
  - [Поля: обязательные и не обязательные для редактирования](#поля-обязательные-и-не-обязательные-для-редактирования)
  - [Поля: с галочкой checkbox и переключателями radio](#поля-с-галочкой-checkbox-и-переключателями-radio)
  - [Поля: с корректно и некорректно введенными данными](#поля-с-корректно-и-некорректно-введенными-данными)
  - [Элементы: попадающие и не попадающие в числовой диапазон number](#элементы-попадающие-и-не-попадающие-в-числовой-диапазон-number)
  - [Комбинирование псевдоклассов](#комбинирование-псевдоклассов)

## Глава 1: [Знакомство с CSS](https://htmlacademy.ru/courses/41)  

### CSS-правило.  
Каждое CSS-правило содержит хотя бы один селектор и свойство.
```css
селектор {
  свойство1: значение;
  свойство2: значение;
}
```  

### Селекторы:  
#### 1. По именам тегов.  
```css
p { ... }
```  

#### 2. По классам.  
```css
.help { ... }
```  

> Подробнее эта тема разбирается в курсе «[Селекторы](https://htmlacademy.ru/courses/42)».  

### Оформление текста.  
```text-decoration: underline;``` — подчеркнуть текст.  
```font-weight: bold;``` — сделать текст полужирным.  
```font-style: italic;``` — сделать текст курсивом.  

> Подробнее эта тема разбирается в курсе «[Оформление текста, часть 1](https://htmlacademy.ru/courses/43)».  

### Размеры и отступы.  
```margin-left: 50px;``` — внешний левый отступ 50 пикселей.  
```padding: 20px;``` — внутренний отступ с четырех сторон 20 пикселей.  
```width: 50%;``` — ширина блока 50%.  

> Подробнее эта тема разбирается в курсе «[Блочная модель документа](https://htmlacademy.ru/courses/44)».  

### Позиционирование.  
Позиционировать элементы можно несколькими способами:  
1. ```position``` — свойство, переключающее режимы позиционирования.   
```css
position: absolute; /* Абсолютное позиционирование исключает элементы с потока */
```  

2. ```top```, ```right```, ```bottom```, ```left``` — свойства расположения элементов.   
```css
left: 100px; /* сместить вправо (отступ слева) на 100 пикселей */
bottom: 200px; /* сместить вверх (отступ снизу) на 100 пикселей */
```  

3. ```z-index``` — свойство, управляющее порядком слоев.  

> Подробнее эта тема разбирается в курсе «[Позиционирование](https://htmlacademy.ru/courses/45)».  

### Сетки.
*Сетка* или *раскладка* — взаимное расположение основных блоков сайта. Сетка может быть фиксированной или тянущейся, когда ширина блоков изменяется в зависимости от ширины браузера. Ей можно управлять, например, с помощью свойства ```float```.  

    > Подробнее эта тема разбирается в курсе «[Сетки](https://htmlacademy.ru/courses/65)».  

### Декоративные свойства.
```background-color: #dff0d8;``` — цвет фона.  
```color: #468847;``` — цвет элементов.  
```border-radius: 5px;``` — радиус округления углов рамки 5 пикселей.  

> Подробнее эта тема разбирается в курсах «[Фоны, часть 1](https://htmlacademy.ru/courses/53)» и «[Оформление текста, часть 1](https://htmlacademy.ru/courses/43)».  

### Каскадность и приоритеты.  
Когда для одного и того же элемента есть несколько CSS-правил с одинаковыми свойствами, браузер использует понятия *приоритетов* и *специфичности*, чтобы выбрать значение свойства из нескольких возможных.  
Стили по приоритету:  
1. Атрибута ```style``` - его стили самые приоритетные.  
2. Селектор с ```#id```.  
3. Селектор с ```.классом```.  
4. Селектор с ```именем тега```.  

> Подробнее эта тема разбирается в курсе «[Наследование и каскадирование](https://htmlacademy.ru/courses/66)».  

### Наследование.  
*Наследование* — часть стилей может передаваться от родительского элемента к дочерним (вложенным в него). Например, все элементы внутри тега body являются дочерними по отношению к нему. Если для body в стилях задать цвет текста красным, то цвет всех остальных элементов тоже станет красным.  

*Наследование работает не для всех свойств.* Некоторые свойства применяются только к самому элементу и не переходят к его потомкам. К таким ненаследуемым свойствам относятся: ширина, высота, отступы, режим позиционирования и другие.  

> Подробнее эта тема разбирается в курсе «[Наследование и каскадирование](https://htmlacademy.ru/courses/66)».  



## Глава 2: [Селекторы, часть 1](https://htmlacademy.ru/courses/42)  

### ```Виды селекторов```  

### 1. По тегам.  
```css
тег { ... }
```  

### 2. По классам.  
```css
.имя класса { ... }
```  

### 3. Контекстные.  
Контекстые (вложенные) селекторы — для вложенных в друг друга элементов.  
```css
.имя_класса .имя_класса2 имя_тега { ... }
```  

### 4. Соседние селекторы.  
Для рядом стоящих элементов.  
```css
селектор1 + селектор2 { ... }
```  

*Для управления стилем соседнего элемента* применяются соседние селекторы. Если нужно указать одно свойство в зависимости от другого.  

* Используются только для рядом стоящих элементов.  
* Свойство применяется для элемента, который стоит после знака ```+```.  
* Если нужно указать стиль для рядом стоящего элемента, но это потомок или родитель, используют *контекстные селекторы* (обычную каскадность), где стили указываются через пробел.  

Пример 1:  
```css
/* CSS-стили */
b + i {color: blue;}
```  
```html
<!-- HTML-код -->
<p>Lorem <b>ipsum</b> dolor sit amet, <i>consectetuer</i> adipiscing elit.</p>
<p>Lorem ipsum dolor sit amet, <i>consectetuer</i> adipiscing elit.</p>
```  

Получится:  
Lorem **ipsum** dolor sit amet, *consectetuer* adipiscing elit.  
Lorem ipsum dolor sit amet, *consectetuer* adipiscing elit.  

Пример 2:  
```css
/* CSS-стили */
.first + li {color: blue;}
.fourth + li {color: blue;}
```  
```html
<!-- HTML-код -->
<li class="first">1</li>
<li>2</li>
<li>3</li>
<li class="fourth">4</li>
<li>5</li>
```  

Так как ```li class="first"``` стоял рядом с ```li```, у которого стояла цифра ```2```.  
Также и для ```li class="fourth"``` и ```li``` с цифрой ```5```.  

### 4b. Контекстные и соседние селекторы.  
```css
.player-1 .hit + .miss { ... }
```  

*Контекстные и соседние селекторы можно комбинировать.* Селектор ```.player-1 .hit + .miss``` сработает для тега с классом ```miss```, если сразу перед ним расположен тег с классом ```hit``` и оба тега расположены внутри тега с классом ```player-1```.  

### 5. Дочерние селекторы.  
Для рядом стоящих потомков.  
```css
.селектор1 > .селектор1 > .селектор3 { ... }
```  

*Потомок* — любой элемент, расположенный внутри родительского.  
*Дочерние элементы* — ближайшие потомки.  
Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Особенно это полезно при работе с многоуровневыми списками.  

Пример:  
```css
/* CSS-стили */
/* задать синий цвет первым элементам span находящимся в первых элементах списка li.  */
ul > li > span {color: blue}
```  
```html
<!-- HTML-код -->
<ul>
  <li><span>...</span></li>
  <li><span>...</span></li>
</ul>
```  

```<li>``` по отношению к ```<ul>``` — дочерний элемент и потомок.  
```<span>``` по отношению к ```<ul>``` — не дочерний элемент, но потомок.  

### 6. Селекторы атрибутов.  
*Стиль применяется к тем тегам, внутри которых добавлен указанный атрибут.* Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями.  

```css
input[checked] { ... } /* выбрать поля формы, которые выбраны по умолчанию */
input[type="submit"] {border-color: green;} /* выбрать текстовые поля формы */
```  

### 7. Селекторы по id.  
```css
#имя_тега { ... }
```  
Но следует помнить, что использование селекторов по ```id``` при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.


### ```Псевдоклассы```  

*Псевдоклассы пишутся без пробела после тега.*  

```css
селектор:псевдокласс {...}
```  
```a:visited {сolor: blue}``` — псевдокласс ```visited``` задает синий цвет для посещенной ссылки.  

### Элементы: первый и последний.  
```css
li:first-child {сolor: blue} /* у первого дочернего элемента списка синий цвет */
li:last-child {сolor: blue} /* у последнего элемента списка синий цвет */
```

### Элементы: по порядковому номеру.  
```css
li:nth-child(2) {сolor: blue} /* синий цвет у 2-го элемента списка */
li:nth-child(5) {сolor: blue} /* синий цвет у 5-го элемента списка */
li:nth-child(2n) {сolor: blue} /* синий цвет у каждого 2-го (всех четных) элемента списка */
```

Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.  
```css
.shooter-2 li:nth-child(3) {сolor: blue} 
/* синий цвет у 3-го элемента списка, находящегося внутри класса .shooter-2 */  
```

Другие виды записи псевдокласса:  
```css
:nth-child(odd) /* нечетные элементы */
:nth-child(even) /* четные элементы */
:nth-child(n+5) /* первых 5 элементов */
:nth-child(-n+7) /* все, кроме первых 7 элементов */
:nth-child(n+8):nth-child(-n+14) /* от 8 до 14 элемента включительно */
:nth-child(n+4):nth-child(-n+18):nth-child(odd) /* только нечетные с 4 по 18 элементов */ 
```

### Элементы: интерактивные.  
Элементы, с которыми взаимодействует пользователь.  

#### A. Когда наведен курсор мыши.  
```css
.tr:hover { ... }
```  

Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и интерактивность, так как элементы начинают реагировать на действия пользователя, изменяя свой внешний вид.  

Динамические эффекты с помощью ```:hover```.  

```css
селектор1:hover селектор2. /* Обычно работают по такому принципу */
```  

Пример, выпадающее меню:  

```css
/* Прячет подменю на элементе меню */
li.top ul.submenu {
  display: none;
}

/* Если на пункт меню наведет курсор, то показывает подменю */
li.top:hover ul.submenu {
  display: block;
}
```  

#### B. Псевдоклассы для ссылок.  
```css
a:link { ... }    /* Ещё не посещенные ссылки */
a:visited { ... } /* Посещенные ссылки */
a:hover { ... }   /* Ссылки, когда на них наведен курсор мыши */
a:active { ... }  /* Ссылки, когда на них зажата кнопка мыши */
```  

#### C. Элемент в фокусе (выделен). 
Например, если переключаться между элементами с помощью ```tab```.  
```css
input:focus {...}
```


## Глава 3: [Наследование и каскадирование](https://htmlacademy.ru/courses/66)  

### ```Общие сведения```  

### Иерархическое дерево.  
HTML-документ представляет собой иерархическое дерево. Это означает, что у каждого элемента (кроме корневого) есть только один родитель, т.е. элемент, внутри которого он располагается. У корневого раздела родитель отсутствует.  

### Наследуемые свойства.  
* *К наследуемым свойствам относятся в первую очередь свойства, определяющие параметры отображения текста*: ```font-size```, ```font-family```, ```font-style```, ```font-weight```, ```color```, ```text-align```, ```text-transform```, ```text-indent```, ```line-height```, ```letter-spacing```, ```word-spacing```, ```white-space```, ```direction``` и т.д.  
* Также к наследуемым свойствам относятся: ```list-style```, ```cursor```, ```visibility```, ```border-collapse``` и др., но они используются значительно реже.  

Весь список наследуемых свойств есть в [стандарте CSS](https://www.w3.org/TR/CSS21/propidx.html). Значение "yes" в колонке "Inherited?".  

### Ненаследуемые свойства.  
Как правило, все остальные свойства относятся к ненаследуемым.  
* *Параметры позиционирования, размеров, отступов, фона, рамок относятся к ненаследуемым свойствам*. А именно: ```background```, ```border```, ```padding```, ```margin```, ```width```, ```height```, ```position``` и др.  

### ```Наследственность и каскадирование```  

### Принудительное наследование.  
```css
p { background: inherit; }
```  
Свойство с ```inherit``` принимает такое же значение, как и у родительского элемента. Значение ```inherit``` может быть использовано для усиления наследуемых значений, а также в свойствах, которые обычно не наследуются.  

### Каскадирование.  
CSS-правила существуют как минимум в трёх разных местах:  
* В подключаемом файле ```style.css``` для селекторов ```p``` или ```.text```.  
* В атрибуте ```style=""```.  
* В стандартных стилях отображения, встроенных в браузер.  

Каскадирование определяет, какие именно свойства из этих источников применятся к данному абзацу.  

Имеется три основные концепции, управляющие порядком, в котором применяются CSS-свойства:  
1. Важность.  
2. Специфичность.  
3. Порядок исходного кода.  

Конкретные примеры.  
1. **Если приоритет одинаковый - сработает тот стиль, что расположен ниже**.  
```html
<p class="red blue">Синий или красный?</p> 
```  
```css
.blue { color: blue; }
.red { color: red; }

/* Красный, потому что CSS-правило стоит в коде ниже */
```  

2. **Более специфичные селекторы имеют больший приоритет**.  
*Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.*  
```html
p class="red blue">Синий или красный?</p>
```  
```css
p.blue { color: blue; }
.red { color: red; }

/* Синий, потому что p.blue более специфичный селектор */
```  

Ещё пример:  
```html
<div class="experiment">
  <p class="red blue">Синий или красный?</p>
</div>
```  
```css
p.blue { color: blue; }
.experiment .red { color: red; }

/* Красный, потому что .experiment .red более специфичные селекторы */
```  

Ещё пример:  
```html
<div id="experiment-1" class="experiment">
  <p class="red blue">Синий или красный?</p>
</div>
```  
```css
#experiment-1 .blue { color: blue; }
.experiment .red { color: red; }

/* Синий, потому что #experiment-1 более специфичный селектор. 
Может существовать только один тег с определенным значением id. */
```  

3. **CSS-правила, которые прописаны в style="" тега обладают наивысшим приоритетом**.  
Но такой способ задания стилей не приветствуется в профессиональной вёрстке сайтов и годится только для создания быстрых прототипов.  
```html
<p style="color: red;" class="blue">Синий или красный?</p>

<!-- Красный, потому что прописан в стилях тега через style -->
```  

4. **Любой приоритет можно переопределить свойством ```!important```**.   
Но при вёрстке не рекомендуется часто использовать ```!important```. По возможности нужно стараться обходиться без него.  
```html
<p style="color: red;" class="blue">Синий или красный?</p>
```  
```css
.blue { color: blue !important; }

/* Синий, потому что #experiment-1 более специфичный селектор. 
Может существовать только один тег с определенным значением id. */
```  

### Специфичность селектора.  
Специфичность селектора разбивается на 4 группы:  
* Встроенный стиль ```style="..."``` - вес 1000.  
* По ```идентификатору``` - вес 100.  
* По ```классу```, псевдоклассу, селектору атрибутов - вес 10.  
* По ```селектору типов элементов``` (тегов), ```псевдо-элементов``` - вес 1.  

Пример:  
```html
<div id="floor">
  <span class="cat-in-box">Кексик</span>
</div>
```  
```css
span { background-color: #27ae60; } /* Зелёный - 1 */
div span { background-color: #2980b9; } /* Синий - 1+1) */
#floor .cat-in-box { background-color: #34495e; } /* Мокрый асфальт - 100+10 */
.cat-in-box { background-color: #8e44ad; } /* Фиолетовый - 10 */
#floor span { background-color: #c0392b; } /* Красный - 100+1 */
div .cat-in-box { background-color: #e67e22; } /* Оранжевый - 1+10 */

/* Коробка будет цвета мокрого асфальта, потому что больше всего вес - 110 */
```  

### Перекрестное наследование.  
Перекрестное наследование — способ создания классов у HTML-тегов.  
```html
<a class="button button-send">Отправить</a>
```  

Пример:  
* На странице используются кнопки разного назначения: для отправки форм, для сброса информации в полях формы, как элементы навигации и т.д.
* Можно вынести общее оформление (размеры, отступы и т.д.) для всех кнопок в отдельное CSS-правило для класса, например, ```.button```.
* А затем создать дополнительные CSS-правила, в которых будут определены только различающиеся свойства этих кнопок, например, цвет фона. Для этих правил можно использовать такие названия классов: ```.button-send```, ```.button-clear```, ```.button-navigation```.
* Каждая кнопка в HTML-коде будет иметь два класса: общий и дополнительный.



## Глава 4: [Селекторы, часть 2](https://htmlacademy.ru/courses/57)  

### ```Псевдоклассы```   

### Элементы: содержащие сразу несколько селекторов.  
```css
.class1.class2 { ... }
```  
```html
<!-- Стили будут применяться в этом случае -->
div class="class1 class2">Блок с двумя классами</div> 
```  

### Элементы: НЕ содержащие указанный селектор.  
```css
li:not(:last-child) { ... } /* все теги <li>, НЕ являющиеся последними в их родителе */
```  

Можно использовать:  
* псевдоклассы;  
* теги;  
* идентификаторы;  
* классы;  
* селекторы атрибутов;  
* Комбинировать с другими. Объединять можно неограниченное количество селекторов.  

```css
/* Будут выбраны все теги <li>, которые НЕ являются первыми и последними в их родителе. */
li:not(:first-child):not(:last-child) { ... }
```  

Нельзя использовать:  
* двойной псевдокласс: ```:not(:not(...))```;  
* объединенные селекторы: ```li:not(.heart.jack)```;  
* псевдоэлементы: ```li:not(::after)```;  
* селекторы-потомки, групповые селекторы или комбинации тегов: ```li:not(a span)``` или ```li:not(a + span)```;  

### Элементы: по порядковому номеру — с конца.  
```css
li:nth-last-child(2) { ... } /* Выделить предпоследний элемент (второй элемент с конца) */
```  

У ```:nth-last-child``` в отличие от псевдокласса ```:nth-child```, отсчет ведется не от первого элемента, а от последнего. Вот и все различия.  

### Элементы: первый и последний — c  учетом типа элемента.  

#### A. Первый элемент родителя с учетом типа элемента.  
```html
<body>
  <div class="paper"> ... </div>
  <ul class="cards"> ... </ul>
  <ul class="cards"> ... </ul>
</body>
```  
```css
/* не выберется ничего, потому что первым дочерним элементом body является div, а в стилях он указан как ul */
ul:first-child { background-color: #ffffee; } 
/* выберется первый ul среди всех дочерних ul в своем родителе - будет выбрана первая строка с картами. */
ul:first-of-type { background-color: #ffffee; }
```  

#### B. Последний элемент родителя с учетом типа элемента.  
```css
ul:last-of-type { ... }
```  

### Элементы: по порядковому номеру — с учетом типа элемента.  
```:nth-of-type``` работает почти так же, как и ```:nth-child```. Разница заключается в том, что он учитывает тип элемента.  
* Нумерация элементов при использовании ```:nth-of-type``` идет только между потомками одного родителя заданного типа.  
* Нумерация элементов при использовании ```:nth-child``` идет между всеми потомками одного родителя.  

Пример:  
```span:nth-of-type(3)``` — выделит третий ```span```.  
```strong:nth-of-type(5)``` — выделит пятый ```strong```.  

### Элементы: по порядковому номеру — с учетом типа элемента, с конца.  
```css
ul:nth-last-of-type(2) { ... } /* Второй элемент с конца, с учетом типа элемента */
```  

### Теги без дочерних элементов (и текстовых узлов).  
```css
ul:empty { ... } /* Выберутся все пустые элементы ul */
```  

### Единственный дочерний элемент внутри родителя.  
```css
li:only-child { ... } 
```  
```html
<ul class="cards">
  <!-- Стили применятся для li, это единственный дочерний элемент внутри тега ul -->
  <li class="queen heart"></li> 
</ul>
<ul class="cards">
  <li class="king club"></li>  <!-- Стили не применятся для этих li -->
  <li class="ace spade"></li>  <!-- Так как они не единственные дочерние элементы -->
  <li class="jack heart"></li> <!-- Внутри теги ul -->
</ul>
```  

### Единственный дочерний элемент внутри родителя — c учетом типа элемента.  
```css
p:only-of-type { ... }
```  

### ```Виды селекторов```  

### 8. Селектор: последующие элементов.  
Стили применятся к элементу, подходящему под ```селектор2```, только если перед ним расположен элемент, подходящий под ```селектор1```.  
```css
селектор1 ~ селектор2 { ... }
```  

Пример:  
```html
<ul class="cards">
  <li class="king diamond">
  <li class="queen heart">
  <li class="jack spade">
  <li class="ace heart">
  <li class="king club">
</ul>
```  
```css
.queen.heart + li { background-color: #ffff99; } // выделит только одну карту - jack spade
.king.diamond ~ li { background-color: #99ddff; } // выделит все карты под king diamond
```  

### ```Псевдоэлементы```  

### Псевдотег: до элемента.  
```css
.heart::before {
  content: "Черви"; /* Текст внутри пседоэлемента */
  color: red;       /* Стили псевдоэлемента */
}
```  
```html
<div class="queen heart">
  <before style="color: red;">Черви</before>
  <em>Дама</em>
</div>
```  

### Псевдотег: после элемента.  
```css
.heart::after { content: "Черви"; }
```  
```html
<div class="queen heart">
  <em>Дама</em>
  <after>Черви</after>
</div>
```  

Псевдоэлементы ```::before``` и ```::after``` можно использовать одновременно.  

*Можно задавать псевдоэлементам любые CSS-свойства*. Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее. Этими возможностями особенно часто пользуются при создании различных декоративных эффектов.  

### Стиль: первой строки.  
```css
p::first-line { ... } /* задает стиль первой строки элемента */
```  

* Длина первой строки зависит от: используемого шрифта, размера окна браузера, ширины блока, языка и т.д.  
* В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона.  

### Стиль: первого символа.  
```css
p::first-letter { ... } /* задает стиль первой буквы элемента */
```  

* К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.  



## Глава 5: [Селекторы, часть 3](https://htmlacademy.ru/courses/58)  

### Атрибуты: начинающиеся с определенных символов.  
```css
div[class^="bar"] { ... } 
/* все элементы у div, у которых значение класса 
(может быть любой другой атрибут, например, name) 
начинается на "bar" */
```  

**Пример применения**.  
Есть три класса для задания колонок разной ширины, например: ```column-1```, ```column-2``` и ```column-3```.  
У этих классов часть свойств повторяется, а разной является только ширина.   
Чтобы не дублировать CSS-код - можно вынести общие свойства колонок в правило с селектором ```[class^="column-"]```, а в остальных правилах можно задать только ширину:  

```css
[class^="column-"] {
  /* общие свойства: отступы, рамки, фон и т.д. */
}
.column-1 { width: 100px; }
.column-2 { width: 200px; }
.column-3 { width: 300px; }
```  

### Атрибуты: заканчивающиеся определенными символами.  
```css
a[href$=".pdf"] 
/* все элементы у ссылок, у которых значение ссылки 
(может быть любой другой атрибут) 
заканчивается на ".pdf" */
```  

**Пример применения**.  
На сайте есть раздел с файлами для скачивания в разных форматах и нужно для каждого типа файлов добавить свою иконку.  
```html
<a href="batman.pdf">Скачать</a>
<a href="superman.doc">Скачать</a>
```  

В этом случае вы можете назначать иконки в CSS по расширениям файлов:  
```css
a[href$=".pdf"] { /* иконка для pfd */ }
a[href$=".doc"] { /* иконка для doc */ }
```  

*Подстрока чувствительна к регистру.* Пример двух разных значений:  
```css
input[value$="кекс"] { color: #3498db; }
input[value$="Кекс"] { color: #e74c3c; }
```  

### Атрибуты: имеющие в названии определенные символы.  
```css
div[class*="person"] /* все элементы, у которых класс содержит символы person */
```  

### Атрибуты: имеющие в названии определенное слово.  
```css
div[class~="name"] /* все элементы, у которых класс содержит символы name */
```  

Входить должно именно слово, а не просто подстрока. То есть вхождение name должно содержать с обеих сторон разделители: пробелы или начало/конец строки.  

### Атрибуты: имеющие в начале или содержащее определенные символы.  
```css
div[class|="bar"] /* все элементы, у которых класс содержит символы name */
```  

В данном случае будут выбраны все элементы, у которых значение атрибута ```foo``` содержит префикс ```bar```, то есть либо полностью совпадает с ```bar```, либо начинается со строки ```bar-```(наличие знака переноса существенно).  
То есть есть два варианта:  
1. ```[foo="bar"]``` — все элементы, у которых значение атрибута ```foo``` полностью совпадает со значением ```bar```.  
2. ```[foo^="bar-"]``` — все элементы, у которых значение атрибута ```foo``` начинается со значения ```bar-```.  

### Элементы: не заблокированные и заблокированные.  
```css
input:enabled { ... } /* все не заблокированные элементы */
input:disabled { ... } /* все заблокированные элементы */
```  

### Поля: доступные и недоступные для редактирования.  
```css
input:read-write { ... } /* доступные для редактирования поля */
input:read-only { ... } /* доступные только для чтения поля */
```  

**Если браузер не поддерживает**.  
В случае, если браузер не поддерживает такие селекторы, их можно заменить на аналогичные:  
```css
input[readonly] { ... } /* аналог :read-only */
input:not([readonly]) { ... } /* аналог :read-write */
```  

Однако, ```input:not([readonly])``` помимо доступных для редактирования текстовых полей выберет кнопки и другие нетекстовые поля ```input```, например, ```input[type="submit"]```.  

**В Mozilla Firefox**.  
В браузере Mozilla Firefox (на момент написания курса) работают ```:read-write``` и ```:read-only```  только с префиксом ```-moz-```. То есть нужно использовать ```:-moz-read-only``` и ```:-moz-read-write```.  

### Поля: обязательные и не обязательные для редактирования.  
```css
input:required { ... } /* все обязательные для заполнения поля */
input:optional { ... } /* всем НЕ обязательные для заполнения поля */
```  

### Поля: с галочкой ```checkbox``` и переключателями ```radio```.  
```css
input:checked { ... } /* поля с типами checkbox или radio */
```

### Поля: с корректно и некорректно введенными данными.  
```css
input:valid { ... } /* поля, где данные введены корректно */
input:invalid { ... } /* поля, где данные введены не корректно */
```  

### Элементы: попадающие и не попадающие в числовой диапазон ```number```.  
```css
input:in-range { ... } /* элементы, значение которых попадает в указанный диапазон */
input:out-of-range { ... } /* элементы, значение которых НЕ попадает в указанный диапазон */
```  

### Комбинирование псевдоклассов.  
*Можно комбинировать псевдоклассы.*  

Пример 1:  
```css
img[src$="jpg"][alt*="Кекс"]::before { ... }
```  

Пример 2:  
```css
input[value*=Кекс]:required:valid { ... }
```  

Пример 3:  
```css
input:checked ~ .item { color: red; } 
/* создаст динамический эффект: 
ставишь галочку - красный цвет появляется, 
убираешь галочку - исчезает */
```  
